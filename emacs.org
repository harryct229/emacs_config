#+TITLE: Tung Dao's Emacs configuration
#+AUTHOR: Tung Dao

* Usage

** Obtaining the Source

   You can find the latest version of the configuration in [[https://github.com/tungd/dotfiles][the GitHub
   repository]]. The meat of it (and the source of this document) is the
   =emacs.org= file.

   Big thank to Noah Frederick for his [[https://github.com/noahfrederick/dots][awesome Emacs setup]]. I have stolen
   many of his ideas.

** Installation

   I use =package.el= to manage Emacs packages and their dependencies. [[https://github.com/cask/cask][Cask]]
   is an alternative, however I find it hard to use on Windows, so I went
   with the vanila =packages.el= instead.

   Still, the setup is installable from scratch. Just start Emacs, open
   =~/.emacs.d/packages.el= and evaluate the buffer;

** Commentary

   Any variables, functions, or macros defined in this configuration are
   "namespaced" with a prefix of ~td/~. This is only a convention for easily
   distinguishing between built-in functions and those defined in this
   configuration or another package, and has no other special significance.

** Configuring Packages

   I use [[https://github.com/jwiegley/use-package][use-package]] to autoload packages. It provides a DSL for setting up
   autoloads and keybindings, and for deferring the loading of packages that
   might otherwise slow down Emacs's startup.

   #+NAME: init-before
   #+BEGIN_SRC emacs-lisp :tangle no
     (require 'use-package)
   #+END_SRC

* Emacs Initialization

** Paths

   Keep any Elisp files not installed from a package repository in the
   =vendor/= directory:

   #+NAME: init-before
   #+BEGIN_SRC emacs-lisp :tangle no
     (setq gc-cons-threshold (* 4 1024 1024))

     (defvar td/vendor-directory (concat user-emacs-directory "vendor/"))
     (add-to-list 'load-path td/vendor-directory)
   #+END_SRC

   Keep theme files in the =themes/= directory:

   #+NAME: init-before
   #+BEGIN_SRC emacs-lisp :tangle no
     (setq custom-theme-directory (concat user-emacs-directory "themes/"))
   #+END_SRC

   Keep temporary files in a separate directory:

   #+NAME: init-before
   #+BEGIN_SRC emacs-lisp :tangle no
     (defvar td/data-directory (concat user-emacs-directory "data/"))
     (unless (file-exists-p td/data-directory)
       (mkdir td/data-directory))
   #+END_SRC

** Benchmarking

   It's useful to measure how long it takes Emacs to start up, so
   let's show the total time in a message:

   #+NAME: init-after
   #+BEGIN_SRC emacs-lisp :tangle no :tangle no
     (defun td/show-startup-time ()
       "Show Emacs's startup time in the minibuffer"
       (message "Startup time: %s seconds."
                (emacs-uptime "%s")))

     (add-hook 'emacs-startup-hook 'td/show-startup-time 'append)
   #+END_SRC

   [[https://github.com/dholm/benchmark-init-el][benchmark-init.el]] can give us a breakdown of time spent on ~require~
   and ~load~ calls. After Emacs has fully loaded, run the command ~M-x
   benchmark-init/show-durations-tree~ or ~M-x
   benchmark-init/show-durations-tabular~ to get the detailed packages'
   impact on load time.

   #+NAME: init-before
   #+BEGIN_SRC emacs-lisp :tangle no :tangle no
     (require 'benchmark-init)
     (add-hook 'after-init-hook 'benchmark-init/deactivate)
   #+END_SRC

** Platform-specific

   There are a few settings that are only relevant to certain OS:

   #+NAME: init-before
   #+BEGIN_SRC emacs-lisp :tangle no
     (setq delete-by-moving-to-trash t)

     (when (eq system-type 'gnu/linux)
       (exec-path-from-shell-initialize))

     (when (eq system-type 'darwin)
       (setq ns-use-native-fullscreen nil
             ns-command-modifier 'meta
             ns-option-modifier 'super
             trash-directory "~/.Trash/")

       ;; BSD ls does not support --dired. Use GNU core-utils: brew install coreutils
       (when (executable-find "gls")
         (setq insert-directory-program "gls"))

       ;; Derive PATH by running a shell so that GUI Emacs sessions have access to it
       (exec-path-from-shell-initialize))

     (when (eq system-type 'windows-nt)
       (add-to-list 'exec-path "C:\\MinGW\\msys\\1.0\\bin"))
   #+END_SRC

** Server

   The Emacs server allows for using =emacsclient= to quickly pop open a
   new frame in a terminal. To finish editing a file in =emacsclient=,
   use ~C-x #~.

   #+NAME: init-after
   #+BEGIN_SRC emacs-lisp :tangle no
     (use-package server
       :defer 1
       :commands server-running-p
       :config
       (progn
         (unless (server-running-p) (server-start))))
   #+END_SRC

   Here are the most common ways in which =emacsclient= is used:

   | Command                         | Description                     |
   |---------------------------------+---------------------------------|
   | =emacsclient=                     | Edit in existing frame          |
   | =emacsclient -n (--no-wait)=      | Do not wait--return immediately |
   | =emacsclient -c (--create-frame)= | Edit in a new frame             |
   | =emacsclient -t (--tty)=          | Edit in a new terminal frame    |
   | =emacsclient -e (--eval)=         | Evaluate the following Elisp    |

   For more, see =man emacsclient=.

** Temporary Files

   Autosave and backup files (currently disabled) go in =/tmp/=. We
   also prevent Emacs from making "lock files", since they are
   causing problem with build tools such as =gulp=.

   #+NAME: init-after
   #+BEGIN_SRC emacs-lisp :tangle no
     (setq backup-directory-alist
           `((".*" . ,td/data-directory)))
     (setq auto-save-list-file-prefix td/data-directory
           auto-save-timeout (* 5 60))
     (setq create-lockfiles nil)
   #+END_SRC

** Private

   Since this configuration is kept in version control in public view,
   I keep sensitive information (mostly passwords) in a separate file
   encrypted using GnuPG. The file is kept in ~.netrc~ format, so that it can
   be used automagically by Tramp.

   #+NAME: init-after
   #+BEGIN_SRC emacs-lisp :tangle no
     (setq user-full-name "Tung Dao"
           user-mail-address "me@tungdao.com")
   #+END_SRC

** Custom

   Set alternative location for =custom-set-variables= and =custom-set-faces=:

   #+NAME: init-before
   #+BEGIN_SRC emacs-lisp :tangle no
     (setq custom-file (expand-file-name "custom.el" user-emacs-directory))
     (load custom-file 'noerror)
   #+END_SRC

   Define a custom keymap to be used later on.

   #+NAME: init-before
   #+BEGIN_SRC emacs-lisp :tangle no
     (bind-keys :prefix-map td/custom-map :prefix "C-c b")
   #+END_SRC

** Fix

   In Emacs 24.4, there's a bug that breaks every ~cc-mode~ derived,
   including PHP mode. The bug is related to ~cl~ package being used, but
   not required. I'll just go ahead and require ~cl~. This is going to be
   fixed in Emacs 24.5.

   http://lists.gnu.org/archive/html/bug-gnu-emacs/2014-10/msg01332.html

   #+NAME: init-before
   #+begin_src emacs-lisp :tangle no
     (require 'cl)
   #+end_src

* Appearance

** UI

   Hide parts of the GUI that we don't need, namely the graphical tool
   bar and any scroll bars. Also, adjust some of the markers on the fringe.

   #+NAME: appearance
   #+BEGIN_SRC emacs-lisp :tangle no
     (setq default-frame-alist
           '((left-fringe . 16) (right-fringe . 0)
             (border-width . 0)
             (internal-border-width . 0)
             (left . 256)
             (width . 120) (height . 34)
             (font . "Fira Mono 14")))

     (setq-default cursor-type '(bar . 3))

     ;; Fallback font for missing Unicode glyph
     ;; (set-fontset-font
     ;;  nil '(#x0250 . #x02af) (font-spec :family "DejaVu Sans Mono"))

     (when (fboundp 'tool-bar-mode)
       (tool-bar-mode -1))
     (when (fboundp 'scroll-bar-mode)
       (scroll-bar-mode -1))
     (when (fboundp 'blink-cursor-mode)
       (blink-cursor-mode -1))
     (unless (and (eq system-type 'darwin) (display-graphic-p))
       (when (fboundp 'menu-bar-mode)
         (menu-bar-mode -1)))

     (setcdr
      (assoc 'truncation fringe-indicator-alist) nil)

     (let ((display-table
            (or standard-display-table
                (setq standard-display-table (make-display-table)))))
       (set-display-table-slot display-table 'truncation ?¬)
       (set-display-table-slot display-table 'vertical-border ?\s)
       (set-window-display-table (selected-window) display-table))
   #+END_SRC

   Load the theme, which determines colors and font variants. Solarized is
   a very popular one.

   #+NAME: appearance
   #+BEGIN_SRC emacs-lisp :tangle no
     (load-theme 'adwaita t)
     ;; (load-theme 'custom t)
   #+END_SRC

   Highlight the current line.

   #+NAME: appearance
   #+BEGIN_SRC emacs-lisp :tangle no
     ;; (global-hl-line-mode t)
   #+END_SRC

   Display the line and column number in the mode line.

   #+NAME: appearance
   #+BEGIN_SRC emacs-lisp :tangle no
     (line-number-mode t)
     (column-number-mode t)
   #+END_SRC

   #+NAME: appearance
   #+BEGIN_SRC emacs-lisp :tangle no
     ;; (if (fboundp 'toggle-frame-maximized)
     ;;     (add-hook 'emacs-startup-hook 'toggle-frame-maximized))
   #+END_SRC

   Suppress the theme's background color and Emacs's menu bar in
   terminal frames:

   #+NAME: appearance
   #+BEGIN_SRC emacs-lisp :tangle no
     (defun td/after-make-frame (frame)
       (unless (display-graphic-p frame)
         (if (fboundp 'menu-bar-mode) (menu-bar-mode -1))
         (set-face-background 'default "dummy-color" frame)))

     (add-hook 'after-make-frame-functions 'td/after-make-frame)
   #+END_SRC

   #+NAME: appearance
   #+BEGIN_SRC emacs-lisp :tangle no
     (setq ring-bell-function 'ignore)
     (setq inhibit-startup-screen t)

     ;; Set message for *scratch* buffer
     (setq initial-scratch-message
           (concat ";; Hello, Tung.\n"
                   ";; Kẻ thất bại chỉ có một loại,\n"
                   ";; chính là loại người từ bỏ trước khi đạt tới thành công.\n"))

     ;; Use ANSI color in shell
     (add-hook 'shell-mode-hook 'ansi-color-for-comint-mode-on)

     ;; Never require full word answers
     (defalias 'yes-or-no-p 'y-or-n-p)
   #+END_SRC

** Mode-line

   [[https://github.com/Bruce-Connor/smart-mode-line][Smart Mode Line]] provides a fairly understandable mode-line format.

   #+NAME: appearance
   #+BEGIN_SRC emacs-lisp :tangle no
     (use-package smart-mode-line
       :init (sml/setup)
       :config
       (progn
         (add-to-list 'sml/replacer-regexp-list '("^~/Projects/dotfiles/\\(.*\\)/" ":Config:\\1:"))

         (use-package rich-minority
           :init
           (progn
             (add-to-list 'rm-hidden-modes " Undo-Tree")
             (add-to-list 'rm-hidden-modes " yas")
             (add-to-list 'rm-hidden-modes " company")))))
   #+END_SRC

** Highlight

   I switched from ~rainbow-delimiters~ with the ~highlight-parentheses~. My
   impression is that it is better than ~rainbow-delimiters~ in term of
   functionality, however it is also more distracting to see the
   parentheses constantly change their color.

   #+name: appearance
   #+begin_src emacs-lisp :tangle no
     (use-package highlight-parentheses
       :defer 1
       :config (global-highlight-parentheses-mode t))
   #+end_src

   Highlight matching parenthesis, brace, etc.

   #+NAME: appearance
   #+BEGIN_SRC emacs-lisp :tangle no
     (use-package paren
       :defer 1
       :init (setq-default show-paren-delay 0)
       :config (show-paren-mode t))
   #+END_SRC

  #+name: appearance
  #+begin_src emacs-lisp :tangle no
    (use-package highlight-escape-sequences
      :defer 1
      :config (hes-mode t))
  #+end_src

** Color Names and Codes

   Rainbow mode displays textual color representations with a
   corresponding colored background.

   #+NAME: appearance
   #+BEGIN_SRC emacs-lisp :tangle no
     (use-package rainbow-mode
       :commands rainbow-turn-on
       :init
       (add-hook 'prog-mode-hook 'rainbow-turn-on))
   #+END_SRC

** Code Folding

   Code folding is provided by the built-in ~hideshow~ mode. In
   addition, I also use ~hideshowvis~ to add folding marker to the
   fringe. ~hideshowvis~ is not available in any of the ELPA, so I
   manage it myself in the ~vendor~ folder.

   #+name: appearance
   #+begin_src emacs-lisp :tangle no
     ;; (use-package hideshow
     ;;   :init
     ;;   :defer t
     ;;   (progn
     ;;     (require 'hideshowvis)

     ;;     ;; We need an around advice here to access the ov internal variable
     ;;     (defadvice display-code-line-counts
     ;;         (around td/hideshowvis-no-line-count activate)
     ;;       ad-do-it
     ;;       (overlay-put ov 'display " ..."))

     ;;     (hideshowvis-symbols)

     ;;     (defun td/toggle-hiding-on-demand ()
     ;;       (interactive)
     ;;       (unless hs-minor-mode
     ;;         (hs-minor-mode t))
     ;;       (hs-toggle-hiding))
     ;;     (bind-key "C-c C-SPC" 'td/toggle-hiding-on-demand)))
   #+end_src

   #+name: appearance
   #+begin_src emacs-lisp :tangle no
     (use-package origami
       :bind (("C-c C-SPC" . origami-toggle-node)))
   #+end_src

** Popwin

   [[https://github.com/m2ym/popwin-el][Popwin]] forces certain buffers into a temporary window with fixed
   height that spans the entire width of the frame.

   #+NAME: appearance
   #+BEGIN_SRC emacs-lisp :tangle no
     (use-package popwin
       :commands popwin-mode
       :defer 1
       :config
       (progn
         (bind-key "C-x p" popwin:keymap)

         (mapc (lambda (c)
                 (add-to-list 'popwin:special-display-config c))
               '((occur-mode :noselect nil)
                 ("*Org Agenda*" :width 60 :position right :dedicated t :stick t)
                 ("*Compile-Log*" :height 20 :noselect t)
                 ("*Ido Completions*" :noselect t :height 15)
                 ("*cider-error*" :height 15 :stick t)
                 ("*cider-doc*" :height 15 :stick t)
                 ("*cider-src*" :height 15 :stick t)
                 ("*cider-result*" :height 15 :stick t)
                 ("*cider-macroexpansion*" :height 15 :stick t)
                 (shell-mode :height 15)
                 (ag-mode :height 15)))

         (popwin-mode 1)))
   #+END_SRC

** Diff-hl

   #+NAME: appearance
   #+BEGIN_SRC emacs-lisp :tangle no
     (use-package diff-hl
       :defer 1
       :config
       (progn
         (define-fringe-bitmap 'td/diff-hl-bmp [192] 1 16 '(top t))
         (defun td/diff-hl-bmp (type pos) 'td/diff-hl-bmp)

         (setq diff-hl-draw-borders nil
               diff-hl-fringe-bmp-function #'td/diff-hl-bmp)

         (set-face-attribute 'diff-hl-insert nil :background nil :foreground "#81af34")
         (set-face-attribute 'diff-hl-delete nil :background nil :foreground "#ff0000")
         (set-face-attribute 'diff-hl-change nil :background nil :foreground "#deae3e")

         ;; (set-face-attribute 'diff-hl-insert nil :background nil)
         ;; (set-face-attribute 'diff-hl-delete nil :background nil)
         ;; (set-face-attribute 'diff-hl-change nil :background nil)

         (defun diff-hl-overlay-modified (ov after-p beg end &optional len)
           "Markers disappear and reapear is kind of annoying to me.")

         (global-diff-hl-mode t)))
   #+END_SRC

** Frame

   #+NAME: appearance
   #+BEGIN_SRC emacs-lisp :tangle no
     (use-package fullframe
       :config
       (progn
         (fullframe ibuffer ibuffer-quit)

         (defvar td/last-window-configuration nil
           "Last window configuration.")

         ;; Ediff has multiple frames, and does not play nice with fullframe API
         (defun td/store-window-configuration ()
           "Store current window configuration."
           (setq td/last-window-configuration (current-window-configuration)))

         (defun td/restore-window-configuration ()
           "Restore current window configuration."
           (set-window-configuration td/last-window-configuration)))

         (add-hook 'ediff-before-setup-hook #'td/store-window-configuration)
         (add-hook 'ediff-quit-hook #'td/restore-window-configuration 'append)
         (add-hook 'ediff-suspend-hook #'td/restore-window-configuration 'append))
   #+END_SRC

* Editing

  Default input method.

  #+name: editing
  #+begin_src emacs-lisp :tangle no
    (setq default-input-method 'vietnamese-telex)
  #+end_src

** Text Encoding

   Use UTF-8 encoding wherever possible:

   #+NAME: editing
   #+BEGIN_SRC emacs-lisp :tangle no
     (set-default-coding-systems 'utf-8-unix)
     (set-terminal-coding-system 'utf-8-unix)
     (set-keyboard-coding-system 'utf-8-unix)
     (prefer-coding-system 'utf-8-unix)
   #+END_SRC

   Even so, ~ansi-term~ doesn't obey:

   #+NAME: editing
   #+BEGIN_SRC emacs-lisp :tangle no
     (defadvice ansi-term (after advise-ansi-term-coding-system)
       (set-buffer-process-coding-system 'utf-8-unix 'utf-8-unix))
     (ad-activate 'ansi-term)
   #+END_SRC

** Version Control and History

   Undo tree provides a Vim-like branching undo history that can be
   visualized and traversed in another window.

   | Binding | Function                     |
   |---------+------------------------------|
   | =C-x u=   | Show undo tree visualization |

   #+NAME: editing
   #+BEGIN_SRC emacs-lisp :tangle no
     (use-package undo-tree
       :init (global-undo-tree-mode t)
       :config
       (setq undo-tree-visualizer-timestamps t
             undo-tree-visualizer-relative-timestamps t
             undo-tree-history-directory-alist
             (list (cons "." (expand-file-name "undos" td/data-directory)))))
   #+END_SRC

   I used to be a =Magit= user, unfortunately at work I have to use Windows,
   and Magit in Windows is slow as hell, so I fallback to =vc.el= which
   shipped with Emacs by default. It is not terrible though, I even find it
   usefull and consider it is a reasonable replacement for =Magit=.

   | Binding | Function                                        |
   |---------+-------------------------------------------------|
   | =C-c g=   | Show Git status buffer                          |
   | =C-c a=   | Run git amend using the previous commit message |
   | =C-c k=   | Abort commit                                    |
   | =TAB=     | Compact/expand group/hunch                      |
   | =RET=     | View commit detail                              |
   | =n/p=     | Next/Previous file/hunch                        |
   | =s/u=     | Stage/Unstage file                              |

   #+NAME: editing
   #+BEGIN_SRC emacs-lisp :tangle no
     (use-package vc-hooks
       :defer t
       :config (setq vc-follow-symlinks t))

     (use-package vc-dir
       :defer t
       :config
       (progn
         (defun td/vc-git-command (verb fn)
           (let* ((args (vc-deduce-fileset nil t))
                  (backend (car args))
                  (files (nth 1 args)))
             (if (eq backend 'Git)
                 (progn
                   (funcall fn files)
                   (message (concat verb " "
                                    (number-to-string (length files))
                                    " file(s).")))
               (message "Not in a vc git buffer."))))

         (defun td/vc-git-add (&optional revision args comment)
           (interactive "P")
           (td/vc-git-command "Staged" 'vc-git-register))

         (defun td/vc-git-reset (&optional revision args comment)
           (interactive "P")
           (td/vc-git-command
            "Unstaged"
            (lambda (files) (vc-git-command nil 0 files "reset" "-q" "--"))))

         (defun td/vc-git-amend (&optional revision args comment)
           (interactive "P")
           (td/vc-git-command
            "Ammended"
            (lambda (files)
              (vc-git-command nil 0 files
                              "commit" "--amend" "--reuse-message=HEAD"))))

         (defadvice vc-dir-refresh
             (after td/vc-hide-up-to-date-after-refresh activate)
           (vc-dir-hide-up-to-date))

         (bind-keys :map vc-dir-mode-map
                    ("r" . vc-revert-buffer)
                    ("a" . td/vc-git-add)
                    ("u" . td/vc-git-reset)
                    ("A" . td/vc-git-amend))

         (bind-keys :map vc-prefix-map
                    ("r" . vc-revert-buffer)
                    ("a" . td/vc-git-add)
                    ("u" . td/vc-git-reset))))
   #+END_SRC

** Search and Replace

   #+name: editing
   #+begin_src emacs-lisp :tangle no
     (use-package isearch
       :bind (("C-s" . isearch-forward-regexp)
              ("C-r" . isearch-backward-regexp))
       :init
       (progn
         (defun td/isearch-message (&optional c-q-hack ellipsis)
           "Cursor flashing in the echo area makes me crazy."
           (isearch-message c-q-hack nil))

         (setq lazy-highlight-initial-delay 0
               isearch-message-function #'td/isearch-message)

         ;;(require 'isearch-diacritics-fold)
         ))
   #+end_src

   =Anzu= is better than the default =query-replace= commands for a
   number of reasons:
   - Show the current position over total matches.
   - Display search/replace preview (similar to Evil).

   | Binding | Command                                        |
   |---------+------------------------------------------------|
   | =M-%=     | Search/replace with Anzu                       |
   | =C-c r=   | Replace word under cusor inside current 'defun |
   | =C-c R=   | Replace word under cursor over the buffer      |

   #+name: editing
   #+begin_src emacs-lisp :tangle no
     (use-package anzu
       :init (global-anzu-mode t)
       :bind (("M-%" . anzu-query-replace-regexp)
              ("C-c r" . anzu-query-replace-at-cursor-thing)
              ("C-c R" . td/anzu-query-replace-all-at-cursor))
       :config
       (progn
        (setq anzu-mode-lighter ""
              anzu-search-threshold 256
              anzu-minimum-input-length 3)

        (defun td/anzu-query-replace-all-at-cursor ()
          (interactive)
          (let ((anzu-replace-at-cursor-thing 'page))
            (call-interactively 'anzu-query-replace-at-cursor-thing)))))
   #+end_src

** Whitespace and Formatting

   #+NAME: editing
   #+BEGIN_SRC emacs-lisp :tangle no
     (setq-default indent-tabs-mode nil)
   #+END_SRC

   #+NAME: editing
   #+BEGIN_SRC emacs-lisp :tangle no
     (setq require-final-newline t) ; auto-insert final newlines in all files

     (use-package whitespace
       :commands (whitespace-cleanup
                  whitespace-mode)
       :bind ("C-c w" . whitespace-mode)
       :config
       (progn
         (add-to-list 'whitespace-display-mappings
                      '(newline-mark ?\n [?\u00AC ?\n] [?$ ?\n]) t)

         (setq whitespace-line-column nil
               whitespace-style
               '(face
                 tabs tab-mark
                 spaces space-mark
                 newline newline-mark
                 trailing lines-tail
                 space-before-tab space-after-tab))

         (add-hook 'before-save-hook #'whitespace-cleanup)
         (add-hook 'before-save-hook #'delete-trailing-whitespace)))
   #+END_SRC

   Auto-filling refers to hard-wrapping text. The default fill-column
   is 80. We adjust this value for specific modes as needed.

   #+NAME: editing
   #+BEGIN_SRC emacs-lisp :tangle no
     (setq-default
      comment-auto-fill-only-comments t
      fill-column 75)

     (add-hook 'text-mode-hook 'turn-on-auto-fill)
     (add-hook 'prog-mode-hook 'turn-on-auto-fill)
   #+END_SRC

** Spell checking

   Use aspell for spell checking. Installation:

   | Platform  | Command                |
   |-----------+------------------------|
   | Mac OS X  | =brew install aspell=    |
   | Archlinux | =sudo pacman - S aspell= |

   #+NAME: editing
   #+BEGIN_SRC emacs-lisp :tangle no
     (when (executable-find "aspell")
       (use-package ispell
         :bind ("<f8>" . ispell-word)
         :init (setq-default ispell-program-name "aspell"
                             ispell-extra-args '("--sug-mode=ultra" "--lang=en_US")
                             ispell-skip-html t
                             ispell-silently-savep t
                             ispell-really-aspell t))

       (use-package flyspell
         :defer t
         :init (add-hook 'text-mode-hook 'flyspell-mode)
         :config
         (progn
           (require 'flyspell-ignore-faces)
           (put 'org-mode 'flyspell-mode-predicate 'td/flyspell-check-p))))
   #+END_SRC

** Parentheses

   I'm deciding between the built-in ~electric-pair-mode~ and
   ~smartparens~. ~electric-pair-mode~ has better behavior in many cases,
   for example skipping closing pairs, and inserting pairs inside
   strings. It also feels much more lighter. However, ~smartparens~ do
   have its own strength, as it is more flexible, and structural
   editing by manipulating ~s-expression~ is very interesting. The
   current point ratio goes like 6/4 favoring ~smartparens~.

   | Binding         | Function                                                   |
   |-----------------+------------------------------------------------------------|
   | =C-M-k=           | Kill                                                       |
   | =C-M-w=           | Copy                                                       |
   | =M-D=             | Unwrap                                                     |
   | =C-M-t=           | Transpose, very useful switch order of function arguments  |
   | =C-M-<backspace>= | Unwrap and kill things inside that last s-expression       |
   | =C-M-]=           | s-expression oriented ~expand-region~                        |
   | =C-<right>=       | Extend the current s-expression to include next item       |
   | =C-<left>=        | Shrink the current s-expression, giving out the last item  |

   #+name: editing
   #+begin_src emacs-lisp :tangle no
     (use-package smartparens
       :defer t
       :init (smartparens-global-mode t)
       :config
       (progn
         (require 'smartparens-config)
         (sp-use-smartparens-bindings)

         (setq sp-autoinsert-if-followed-by-same 1
               sp-autoescape-string-quote nil
               sp-highlight-pair-overlay nil)

         (sp-pair "{" nil
                  :post-handlers '(:add ("||\n[i]" "RET") ("| " "SPC")))
         (sp-pair "[" nil
                  :post-handlers '(:add ("||\n[i]" "RET") ("| " "SPC")))
         (sp-pair "(" nil
                  :post-handlers '(:add ("||\n[i]" "RET") ("| " "SPC")))

         (defun sp-web-mode-is-code-context (id action context)
           (and (eq action 'insert)
                (or (get-text-property (point) 'part-side)
                    (get-text-property (point) 'block-side))))

         (sp-local-pair 'web-mode "<" nil :when '(sp-web-mode-is-code-context))))
   #+end_src

** Commenting

   #+name: editing
   #+begin_src emacs-lisp :tangle no
     (use-package comment-dwim2
       :commands comment-dwim2
       :init
       (progn
         (setq comment-style 'multi-line)
         (bind-key "C-l" #'comment-dwim-2)))
   #+end_src

** Selecting (Marking)

   For easier marking, I use =expand-region=. To interact with those marks, I
   use =multiple-cursor=.

   #+name: editing
   #+begin_src emacs-lisp :tangle no
     (pending-delete-mode t)

     (setq kill-ring-max 4096
           kill-whole-line t)

     (use-package expand-region
       :bind ("M--" . er/expand-region))

     (use-package multiple-cursors
       :commands (mc/mark-previous-like-this
                  mc/mark-next-like-this
                  mc/skip-to-previous-like-this
                  mc/skip-to-next-like-this
                  mc/mark-all-like-this)
       :init
       (bind-keys ("M-C-9" . mc/mark-previous-like-this)
                  ("M-C-0" . mc/mark-next-like-this)
                  ("M-(" . mc/skip-to-previous-like-this)
                  ("M-)" . mc/skip-to-next-like-this)
                  ("M-C-a" . mc/mark-all-like-this)))

     (bind-key "C-x SPC" 'set-rectangular-region-anchor)
   #+end_src

** Utilities

   These packages provide various conveniences for editing.

   I used to be an Evil mode user, but now I prefer vanila Emacs.
   These are general key bindings which bind to my built-in Emacs
   commands or my defined commands. Key bindings for third-party
   packages are defined separately in their configuration.

   #+NAME: editing
   #+BEGIN_SRC emacs-lisp :tangle no
     (bind-key "M-`" #'other-frame)
     ;; (td/bind "C-M-f" #'td/toggle-fullscreen)

     (defun end-with-newline ()
       (interactive)
       (move-end-of-line 1)
       (newline-and-indent))

     (defun end-with-semicolon ()
       (interactive)
       (move-end-of-line 1)
       (insert ";"))

     (bind-key "RET" #'newline-and-indent)
     (bind-key "M-RET" #'end-with-newline)
     (bind-key "M-;" #'end-with-semicolon)


     (defun td/next-ten-visual-lines ()
       (interactive)
       (next-line 10))

     (defun td/previous-ten-visual-lines ()
       (interactive)
       (previous-line 10))

     (bind-key "M-n" #'td/next-ten-visual-lines)
     (bind-key "M-p" #'td/previous-ten-visual-lines)


     (autoload 'zap-up-to-char "misc" nil :interactive)
     (autoload 'zap-to-char "misc" nil :interactive)

     (bind-key "M-z" #'zap-up-to-char)
     (bind-key "M-Z" #'zap-to-char)


     (defun td/cleanup-buffer ()
       (interactive)
       (indent-region (point-min) (point-max))
       (untabify (point-min) (point-max))
       (whitespace-cleanup))

     (bind-key "M-=" #'td/cleanup-buffer)


     (defun td/join-next-line ()
       (interactive)
       (join-line -1))

     (bind-key "M-J" #'td/join-next-line)


     (defun td/kill-region-or-word ()
       (interactive)
       (call-interactively
        (if (region-active-p) 'kill-region 'backward-kill-word)))

     (bind-key "C-w" #'td/kill-region-or-word)


     (defun td/eval-and-replace ()
       (interactive)
       (backward-kill-sexp)
       (condition-case nil
           (prin1 (eval (read (current-kill 0)))
                  (current-buffer))
         (error (message "Invalid expression")
                (insert (current-kill 0)))))

     (bind-key "C-c C-e" #'td/eval-and-replace)


     (defun extract-variable (begin end var)
       (interactive "r\nsVariable name: ")
       (kill-region begin end)
       (insert var)
       (forward-line -1)
       (newline-and-indent)
       (insert var " = ")
       (yank))

     (defun inline-variable ()
       (interactive)
       (let ((var (current-word)))
         (re-search-forward "= ")
         (let ((value (buffer-substring (point) (point-at-eol))))
           (kill-whole-line)
           (search-forward var)
           (replace-match value))))

     (defun align=: (&optional args)
       "Align region to equal signs or colon"
       (interactive)
       (with-region-or-current-line
        (align-regexp (region-beginning) (region-end) "\\(\\s-*\\)[=|:]" 1 1)))


     (defun open-thing-at-point ()
       (interactive)
       (cond
        ((-when-let (url (thing-at-point 'url))
           (browse-url url)))
        ((-when-let (email (thing-at-point 'email))
           (browse-url (format "mailto:%s" email))))
        ((-when-let (path (thing-at-point 'filename))
           (if (file-exists-p path)
               (find-file path)
             (if (file-exists-p (concat path ".el"))
                 (find-file (concat path ".el"))
               (when (y-or-n-p (format "Create %s?" path))
                 (find-file path))))))))

     (bind-key "M-o" 'open-thing-at-point)

     (defun char-upcasep (letter)
       (eq letter (upcase letter)))

     ;; TOOD: find appropriate key binding for these functions

     (defun capitalize-word-toggle ()
       (interactive)
       (let ((start (car (save-excursion
                           (backward-word)
                           (bounds-of-thing-at-point 'symbol)))))
         (if start
             (save-excursion
               (goto-char start)
               (funcall (if (char-upcasep (char-after))
                            'downcase-region
                          'upcase-region)
                        start (1+ start)))
           (capitalize-word -1))))

     (defun upcase-word-toggle ()
       (interactive)
       (let ((bounds (bounds-of-thing-at-point 'symbol))
             beg end
             (regionp (if (eq this-command last-command)
                          (get this-command 'regionp)
                        (put this-command 'regionp nil))))
         (cond
          ((or (region-active-p) regionp)
           (setq beg (region-beginning)
                 end (region-end))
           (put this-command 'regionp t))
          (bounds
           (setq beg (car bounds)
                 end (cdr bounds)))
          (t
           (setq beg (point)
                 end (1+ beg))))
         (save-excursion
           (goto-char (1- beg))
           (and (re-search-forward "[A-Za-z]" end t)
                (funcall (if (char-upcasep (char-before))
                             'downcase-region
                           'upcase-region)
                         beg end)))))


     (defun find-file-sudo (&optional arg)
       (interactive)
       (unless (and buffer-file-name
                    (file-writable-p buffer-file-name))
         (find-alternate-file
          (concat "/sudo:root@localhost:" buffer-file-name))))


     (defun td/before-save-make-directories ()
       (let ((dir (file-name-directory buffer-file-name)))
         (when (and buffer-file-name (not (file-exists-p dir)))
           (make-directory dir t))))

     (add-hook 'before-save-hook #'td/before-save-make-directories)


     (defun td/after-save-auto-chmod ()
       (when (and (> (length (buffer-string)) 5)
                  (string-equal "#!" (buffer-substring-no-properties 1 4)))
         (shell-command
          (format "chmod u+x %s"
                  (shell-quote-argument (buffer-file-name))))))

     (add-hook 'after-save-hook #'td/after-save-auto-chmod)
   #+end_src

   These are commands to work with files and buffers.

   #+name: editing
   #+begin_src emacs-lisp :tangle no
     (defun delete-current-buffer-file ()
       (interactive)
       (let ((filename (buffer-file-name)))
         (when (and filename (file-exists-p filename))
           (delete-file filename)
           (kill-this-buffer))))

     (defun rename-current-buffer-file (new-name)
       (interactive
        (list (read-string "New name: " (buffer-name))))
       (let ((filename (buffer-file-name)))
         (when (and filename (file-exists-p filename))
           (if (get-buffer new-name)
               (error "Buffer named '%s' already exists!" new-name)
             (progn
               (rename-file filename new-name t)
               (rename-buffer new-name)
               (set-visited-file-name new-name)
               (set-buffer-modified-p nil))))))

     (defun write-file-copy (filename)
       (interactive "F")
       (save-restriction (widen)
                         (write-region (point-min) (point-max) filename)))

     (defun write-timestamped-file-copy (filename)
       (interactive "F")
       (let ((timestamp (format-time-string "%Y%m%d-%H%M%S"))
             (filename-head (file-name-sans-extension filename))
             (filename-ext (file-name-extension filename t)))
         (write-file-copy (expand-file-name (concat filename-head "_" timestamp filename-ext)))))

     (defun write-timestamped-current-file-copy ()
       (interactive)
       (write-timestamped-file-copy (buffer-file-name)))

     (bind-keys :map td/custom-map
                ("r" . rename-current-buffer-file)
                ("d" . delete-current-buffer-file)
                ("t" . write-timestamped-current-file-copy))
   #+END_SRC

** Snippets

   Use [[https://github.com/capitaomorte/yasnippet][YASnippet]] for snippets:

   #+NAME: editing
   #+BEGIN_SRC emacs-lisp :tangle no
     (use-package yasnippet
       :commands yas-global-mode
       :init
       (progn
         (setq yas-snippet-dirs '("~/.emacs.d/snippets"))
         (yas-global-mode t))
       :config
       (progn
         (setq yas-prompt-functions
               '(yas-ido-prompt yas-completing-prompt yas-no-prompt)
               ;; Suppress excessive log messages
               yas-verbosity 1
               ;; I am a weird user, I use SPACE to expand my
               ;; snippets, this save me from triggering them accidentally.
               yas-expand-only-for-last-commands
               '(self-insert-command org-self-insert-command))

         (unbind-key "TAB" yas-minor-mode-map)
         (unbind-key "<tab>" yas-minor-mode-map)
         (bind-key "SPC" 'yas-expand yas-minor-mode-map)))
   #+END_SRC

** Diff

   #+NAME: editing
   #+begin_src emacs-lisp :tangle no
     (use-package ediff
       :defer t
       :init
       (progn
         (defun td/ediff-from-command-line (switch)
           (let ((file-a (pop command-line-args-left))
                 (file-b (pop command-line-args-left)))
             (ediff file-a file-b)))

         (add-to-list 'command-switch-alist '("diff" . td/ediff-from-command-line)))
       :config
       (progn
         (setq ediff-window-setup-function 'ediff-setup-windows-plain
               ediff-split-window-function 'split-window-horizontally)))
   #+end_src

* Navigation and Completion

  #+name: navigation-completion
  #+begin_src emacs-lisp :tangle no
    (use-package which-func
      :defer 1
      :config
      (which-function-mode t))

    (use-package imenu
      :defer t
      :bind ("C-c i" . imenu)
      :config
      (setq imenu-auto-rescan t))
  #+end_src

** Auto Complete

   Take a look at ~company-sort-by-backend-importance~.

   #+name: navigation-completion
   #+begin_src emacs-lisp :tangle no
     (use-package company
       :init
       (progn
         (setq company-backends
               '(company-anaconda
                 company-css
                 (;company-yasnippet
                  company-capf
                  company-dabbrev-code
                  company-keywords)))
         (global-company-mode t))
       :config
       (progn
         (use-package company-lines
           :commands (company-lines))

         (setq completion-cycle-threshold 5)

         (setq company-idle-delay 0.2
               company-auto-complete nil
               company-selection-wrap-around t
               company-echo-delay 0
               company-tooltip-align-annotations t
               company-show-numbers t
               company-minimum-prefix-length 3

               company-auto-complete-chars
               '(?\ ?\( ?\) ?. ?\" ?$ ?\' ?< ?> ?| ?!)

               company-transformers
               '(company-sort-by-occurrence)

               company-frontends
               '(company-pseudo-tooltip-unless-just-one-frontend
                 company-echo-metadata-frontend
                 company-preview-if-just-one-frontend))

         (bind-keys :prefix-map td/completion-map
                    :prefix "M-;"
                    ("s" . company-ispell)
                    ("f" . company-files)
                    ("l" . company-lines))

         (bind-keys :map company-active-map
                    ([escape] . company-abort)
                    ("<tab>" . company-complete-dwim)
                    ("<backtab>" . company-select-previous)
                    ("C-n" . company-select-next)
                    ("C-p" . company-select-previous)
                    ("C-s" . company-filter-candidates)
                    ("C-l" . company-show-location)
                    ("C-j" . company-complete-common)
                    ("C-d" . company-show-doc-buffer))

         (defun company-complete-dwim (&optional arg)
           (interactive "P")
           (let ((pos (point)))
             (indent-according-to-mode)
             (when (and (= pos (point)) (looking-at "\\_>"))
               (if (eq last-command 'company-complete-dwim)
                   (company-select-next)
                 (company-complete-common)))))

         (bind-keys :map company-mode-map
                    ([remap indent-for-tab-command] . company-complete-dwim))))
   #+end_src

** Minibuffer

   #+name: navigation-completion
   #+begin_src emacs-lisp :tangle no
     (use-package savehist
       :defer t
       :init
       (progn
         (setq savehist-file (expand-file-name "savehist" td/data-directory))
         (savehist-mode t)))
   #+end_src

   #+name: navigation-completion
   #+begin_src emacs-lisp :tangle no
     (use-package ido
       :commands (ido-switch-buffer
                  ido-find-file)
       :init
       (progn
         (ido-mode t)
         (ido-everywhere t)
         (ido-ubiquitous-mode t)
         (ido-vertical-mode)
         (flx-ido-mode t))

       :config
       (progn
         (setq ido-save-directory-list-file
               (expand-file-name "ido.last" td/data-directory)
               ido-enable-flex-matching t
               ido-create-new-buffer 'always
               ido-case-fold t
               ido-file-extensions-order
               '(".rb" ".py" ".clj" ".cljs" ".el" ".coffee" ".js" ".ts"
                 ".scss" ".php" ".html" t)
               ido-default-buffer-method 'samewindow
               ido-vertical-define-keys nil
               flx-ido-threshold 2048)

         (add-to-list 'ido-ignore-files "\\.DS_Store")
         (add-to-list 'ido-ignore-files "__pycache__")

         (defun td/minibuffer-home ()
           (interactive)
           (if (looking-back "/")
               (insert "~/")
             (call-interactively 'self-insert-command)))

         (defun td/minibuffer-insert-word-at-point ()
           (interactive)
           (let (word beg)
             (with-current-buffer (window-buffer (minibuffer-selected-window))
               (setq word (thing-at-point 'word)))
             (insert word)))

         (defun ido-goto-line ()
           (interactive)
           (let* ((lines (split-string (buffer-string) "[\n\r]"))
                  (choices (-remove (lambda (l) (zerop (length l))) lines))
                  (line (ido-completing-read "Line: " choices)))
             (push-mark)
             (goto-line (+ 1 (-elem-index line lines)))))

         (bind-key "C-c l" #'ido-goto-line)

         (defun td/ido-hook ()
           (bind-keys :map ido-completion-map
                      ("C-h" . delete-backward-char)
                      ("ESC" . ido-exit-minibuffer)
                      ("C-w" . ido-delete-backward-updir)
                      ("C-n" . ido-next-match)
                      ("C-p" . ido-prev-match)
                      ("TAB" . ido-complete)
                      ("C-l" . td/minibuffer-insert-word-at-point)
                      ("~" . td/minibuffer-home)))

         (add-hook 'ido-setup-hook #'td/ido-hook)))
   #+end_src

   Smex provides Ido completion for =M-x=.

   #+NAME: navigation-completion
   #+BEGIN_SRC emacs-lisp :tangle no
     (use-package smex
       :bind (("M-m" . smex)
              ("M-M" . smex-major-mode-commands))
       :init
       (progn
         (setq smex-save-file (expand-file-name "smex-items" td/data-directory)
               smex-flex-matching t)
         (smex-initialize)))
   #+END_SRC

** Save Place

   Place the point where we left it when last visiting the same file.

   #+NAME: navigation-completion
   #+BEGIN_SRC emacs-lisp :tangle no
     (use-package saveplace
       :init
       (progn
         (setq-default save-place t)))
   #+END_SRC

** Windows

   #+name: navigation-completion
   #+begin_src emacs-lisp :tangle no
     (use-package window-numbering
       :init (window-numbering-mode t)
       :config
       (progn
         (defadvice window-numbering-get-number-string
           (after td/custom-window-numbering-mode-line-string activate)
           (setq ad-return-value (format "[%s] " ad-return-value)))))

     (defun kill-buffer-and-window-silently ()
       (interactive)
       (ignore-errors (kill-buffer-and-window)))

     (bind-keys ("C-c q" . delete-frame)
                ("C-c Q" . delete-window)
                ("C-c k" . kill-buffer-and-window-silently))
   #+end_src

** Buffers

   For more intensive buffer switching and buffer management, we use
   ibuffer, which displays a listing in its own
   buffer. ~ibuffer-saved-filter-groups~ defines rules for grouping buffers
   under categories ("filter groups").

   The [[https://github.com/purcell/ibuffer-vc][ibuffer-vc]] package generates filter groups for consumption by
   ibuffer that categorize buffers by version control repository root.

   #+NAME: navigation-completion
   #+BEGIN_SRC emacs-lisp :tangle no
     (setq confirm-nonexistent-file-or-buffer nil)

     (use-package uniquify
       :config
       (setq uniquify-buffer-name-style 'post-forward
             uniquify-separator " - "
             uniquify-after-kill-buffer-p t
             uniquify-ignore-buffers-re "^\\*"))

     (use-package ibuffer
       :commands ibuffer
       :bind ("C-x C-b" . ibuffer)
       :init
       (progn
         (setq ibuffer-saved-filter-groups
               '(("Config" (or
                            (filename . ".dots/")
                            (filename . ".emacs.d/")))
                 ("Shell"  (or
                            (mode . eshell-mode)
                            (mode . shell-mode)))
                 ("Dired"  (mode . dired-mode))
                 ("Prose"  (or
                            (mode . tex-mode)
                            (mode . plain-tex-mode)
                            (mode . latex-mode)
                            (mode . rst-mode)
                            (mode . markdown-mode)))
                 ("Org"    (mode . org-mode))
                 ("Gnus"   (or
                            (mode . message-mode)
                            (mode . gnus-group-mode)
                            (mode . gnus-summary-mode)
                            (mode . gnus-article-mode)))
                 ("Emacs"  (name . "^\\*.*\\*$")))
               ibuffer-show-empty-filter-groups nil
               ibuffer-expert t)

         (use-package ibuffer-vc
           :commands ibuffer-vc-generate-filter-groups-by-vc-root
           :config
           (progn
             (defun td/ibuffer-apply-filter-groups ()
               "Combine my saved ibuffer filter groups with those generated
          by `ibuffer-vc-generate-filter-groups-by-vc-root'"
               (interactive)
               (setq ibuffer-filter-groups
                     (append (ibuffer-vc-generate-filter-groups-by-vc-root)
                             ibuffer-saved-filter-groups))
               (message "ibuffer-vc: groups set")
               (let ((ibuf (get-buffer "*Ibuffer*")))
                 (when ibuf
                   (with-current-buffer ibuf
                     (pop-to-buffer ibuf)
                     (ibuffer-update nil t)))))

             (add-hook 'ibuffer-hook 'td/ibuffer-apply-filter-groups)))))
   #+END_SRC

   Clean up buffers periodically:

   #+NAME: navigation-completion
   #+BEGIN_SRC emacs-lisp :tangle no
     ;; (use-package midnight)
   #+END_SRC

   #+name: navigation-completion
   #+begin_src emacs-lisp :tangle no
     (defun td/recent-buffer ()
       (interactive)
       (switch-to-buffer (other-buffer (current-buffer) 1)))

     (bind-keys :map td/custom-map
                ("b" . td/recent-buffer))
   #+end_src

** ACE Jump

   #+name: navigation-completion
   #+begin_src emacs-lisp :tangle no
     (use-package ace-jump-mode
       :bind (("M-'" . ace-jump-word-mode)
              ("M-C-'" . ace-jump-char-mode)))
   #+end_src

** Project

   [[https://github.com/bbatsov/projectile][Projectile]] allows easy switching between projects as well as
   finding files and buffers related to the current project, however
   it does not implement its own interface, instead leveraging Ido,
   Helm, or Grizzl.

   Projectile's bindings start with =C-c p=.

   #+NAME: navigation-completion
   #+BEGIN_SRC emacs-lisp :tangle no
     (use-package projectile
       :defer t
       :init (projectile-global-mode t)
       :config
       (progn
         (setq projectile-enable-idle-timer t
               ;; Use static mode line here to eliminate GC. SML already
               ;; displays the current project anyway.
               projectile-mode-line " Proj")

         (bind-keys ("M-l" . projectile-find-file)
                    ([remap projectile-ack] . projectile-ag)
                    ([remap projectile-grep] . projectile-ag))

         (add-to-list 'projectile-globally-ignored-directories "__pycache__")))

     (use-package wgrep
       :defer t
       :init (add-hook 'ag-mode-hook #'wgrep-setup))
   #+END_SRC

   #+name: navigation-completion
   #+begin_src emacs-lisp :tangle no
     (defun td/custom-font-lock-hightlights ()
       (font-lock-add-keywords
        nil '(("\\<\\(FIX\\(ME\\)?\\|TODO\\|HACK\\|REFACTOR\\):"
               1 font-lock-warning-face t)))
       (font-lock-add-keywords
        nil '(("%\\(?:[-+0-9\\$.]+\\)?[bdiuoxXDOUfeEgGcCsSpn]"
               0 font-lock-preprocessor-face t))))

     (add-hook 'prog-mode-hook #'td/custom-font-lock-hightlights)

     (defun td/occur-todos ()
       (interactive)
       (occur "TODO"))
   #+end_src

** Tag

   #+name: navigation-completion
   #+begin_src emacs-lisp :tangle no
     (setq tags-revert-without-query t)
   #+end_src

* Programming

  #+name: programming
  #+BEGIN_SRC emacs-lisp :tangle no
    (use-package indent-guide
      :commands (indent-guide-mode)
      :init
      (add-hook 'python-mode-hook #'indent-guide-mode))

    (use-package electric-case
      :init
      (progn

        (setq electric-case-convert-calls t)

        (defun td/electric-case-js-init ()
          "TODO: documentation."
          )

        (defun td/electric-case-python-init ()
          "TODO: documentation."
          )

        (add-hook 'java-mode-hook #'electric-case-java-init)
        ;; (add-hook 'js2-mode-hook #'electric-case-java-init)
        ;; (add-hook 'js-mode-hook #'electric-case-java-init)
        (add-hook 'python-mode-hook #'td/electric-case-python-init)))
  #+END_SRC

** Compilation

  #+name: programming
  #+begin_src emacs-lisp :tangle no
    (use-package compile
      :defer t
      :init
      (progn
        (defun recompile-with-last-configuration ()
          (interactive)
          (save-some-buffers)
          (when compilation-last-buffer
            (with-current-buffer compilation-last-buffer
              (call-interactively 'recompile))))

        (bind-key "C-c m" 'recompile-with-last-configuration))
      :config
      (progn
        (setq compilation-scroll-output t)

        (defun td/colorize-compilation-buffer ()
          (toggle-read-only)
          (ansi-color-apply-on-region (point-min) (point-max))
          (toggle-read-only))

        (add-hook 'compilation-filter-hook #'td/colorize-compilation-buffer)))
  #+end_src

** Syntax Checking

   Use [[https://github.com/flycheck/flycheck][Flycheck]] to validate syntax on the fly.

   #+NAME: editing
   #+BEGIN_SRC emacs-lisp :tangle no
     (use-package flycheck
       :commands (global-flycheck-mode flycheck-mode)
       :config
       (setq-default flycheck-disabled-checkers
                     '(html-tidy go-build emacs-lisp-checkdoc)))
   #+END_SRC

** Emacs-Lisp

    #+NAME: programming
    #+BEGIN_SRC emacs-lisp :tangle no
      (use-package emacs-lisp-mode
        :mode ("Cask" . emacs-lisp-mode))

      (use-package eldoc
        :commands turn-on-eldoc-mode
        :init (add-hook 'emacs-lisp-mode-hook 'turn-on-eldoc-mode)
        :config
        (progn
          (defun eldoc-message-now ()
            (interactive))

          (setq eldoc-idle-delay 0)

          (defun eldoc--message-command-p (command)
            (eq command 'eldoc-message-now))

          (bind-key "C-c d" #'eldoc-message-now)

          (eldoc-add-command 'eldoc-message-now)))
    #+END_SRC

** Ruby

    #+NAME: programming
    #+BEGIN_SRC emacs-lisp :tangle no
      (use-package ruby-mode
        :mode (("\\.rake$" . ruby-mode)
               ("\\.gemspec$" . ruby-mode)
               ("\\.ru$" . ruby-mode)
               ("Rakefile$" . ruby-mode)
               ("Gemfile$" . ruby-mode)
               ("Capfile$" . ruby-mode)
               ("Puppetfile$" . ruby-mode)
               ("Guardfile$" . ruby-mode)
               ("Vagrantfile$" . ruby-mode)))
    #+END_SRC

** JavaScript

   This section contains configuration for both ~js-mode~ and ~js2-mode~. I
   used to use =js-mode= for editing all JavaScript files, but I now use
   =js2-mode=.

   #+name: programming
   #+begin_src emacs-lisp :tangle no
     (use-package js
       :defer t
       :config
       (setq js-indent-level 2
             js-expr-indent-offset 2
             js-flat-functions t))

     (use-package js2-mode
       :mode "\\.js$"
       :config
       (progn
         (require 'js-indentation)

         (setq-default
          js2-basic-offset 2
          js2-highlight-level 3
          js2-idle-timer-delay 0
          js2-mode-show-parse-errors nil
          js2-strict-missing-semi-warning nil
          js2-indent-switch-body t
          js2-bounce-indent-p nil
          js2-include-node-externs t
          js2-global-externs
          '("jQuery" "Zepto" "$" "location" "Image" "describe" "it" "goog"
            "require" "define" "exports"))))
   #+end_src

** Python

    #+NAME: programming
    #+BEGIN_SRC emacs-lisp :tangle no
      (use-package python
        :config
        (progn
          (setq python-indent-guess-indent-offset nil)

          (defun td/setup-python ()
            (interactive)
            (anaconda-mode t)
            (eldoc-mode t)
            ;; (add-to-list 'company-backends 'company-anaconda)
            )

          (add-hook 'python-mode-hook #'td/setup-python)))
    #+END_SRC

** PHP

   #+name: programming
   #+begin_src emacs-lisp :tangle no
     (use-package php-mode
       :mode "\\.php\\'"
       :config
       (progn
         (setq php-template-compatibility nil
               php-manual-path "~/local/docs/php"
               php-mode-warn-if-mumamo-off nil
               php-mode-coding-style 'drupal)))
   #+end_src

** Web

   I used to be a happy ~mmm-mode~ user; I even added support for some
   interesting stuff. However ~mmm-mode~ needs some updates to work with
   Emacs 24.4, in the mean time I use ~web-mode~.

   #+name: programming
   #+begin_src emacs-lisp :tangle no
     (use-package web-mode
       :mode (("\\.phtml\\'" . web-mode)
              ("/\\(views\\|html\\|templates\\)/.*\\.php\\'" . web-mode)
              ("\\.tpl\\'" . web-mode)
              ("\\.[gj]sp\\'" . web-mode)
              ("\\.as[cp]x\\'" . web-mode)
              ("\\.erb\\'" . web-mode)
              ("\\.mustache\\'" . web-mode)
              ("\\.djhtml\\'" . web-mode)
              ("\\.jinja2\\'" . web-mode)
              ("\\.html?" . web-mode)
              ("\\.hbs\\'" . web-mode))
       :config
       (progn
         (setq web-mode-markup-indent-offset 2)
         (add-hook 'web-mode-hook #'turn-off-auto-fill)
         (add-to-list 'web-mode-imenu-regexp-list
                       '(" \\(ng-[a-z]*\\)=\"\\([a-zA-Z0-9]*\\)" 1 2 "="))))
   #+end_src


   I also use ~emmet-mode~, it's a life-saver.

   #+name: programming
   #+begin_src emacs-lisp :tangle no
     (use-package emmet-mode
       :commands emmet-mode
       :init
       (progn
         (add-hook 'sgml-mode-hook #'emmet-mode)
         (add-hook 'web-mode-hook #'emmet-mode)
         (add-hook 'css-mode-hook #'emmet-mode))
       :config
       (progn
         (setq emmet-indentation 2
               emmet-preview-default nil
               emmet-insert-flash-time 0.1)

         (defadvice emmet-preview
           (after td/emmet-preview-hide-tooltip activate)
           (overlay-put emmet-preview-output 'before-string nil))))
   #+end_src

** CSS/SASS/LESS

   #+name: programming
   #+begin_src emacs-lisp :tangle no
     (defun td/css-imenu-expressions ()
       (add-to-list 'imenu-generic-expression '("Section" "^.*\\* =\\(.+\\)$" 1) t))

     (use-package css-mode
       :mode "\\.css\\'"
       :init
       (progn
         (setq-default css-indent-offset 2)
         (add-hook 'css-mode-hook #'td/css-imenu-expressions)))

     (use-package scss-mode
       :mode "\\.scss\\'"
       :init
       (progn
         (setq scss-compile-at-save nil
               css-indent-offset 2)
         (add-hook 'scss-mode-hook #'td/css-imenu-expressions)))

     (use-package less-css-mode
       :mode "\\.less\\'"
       :init
       (progn
         ;; TODO: customize `less-css-indent-line' to support nested ruleset
         (add-hook 'less-css-mode-hook #'td/css-imenu-expressions)))
   #+end_src

** Markdown

   #+name: programming
   #+begin_src emacs-lisp :tangle no
     (use-package markdown-mode
       :mode (("\\.md$" . markdown-mode)
              ("\\.mkd$" . markdown-mode)
              ("\\.markdown$" . markdown-mode))
       :config
       (progn
         (setq markdown-command "redcarpet"
               markdown-enable-math t
               markdown-header-face '(:inherit font-lock-function-name-face :weight bold)
               markdown-header-face-1 '(:inherit markdown-header-face :height 2.0)
               markdown-header-face-2 '(:inherit markdown-header-face :height 1.6)
               markdown-header-face-3 '(:inherit markdown-header-face :height 1.4)
               markdown-header-face-4 '(:inherit markdown-header-face :height 1.2))

         (add-hook 'markdown-mode-hook #'turn-on-flyspell)
         (add-hook 'markdown-mode-hook #'turn-on-auto-fill)))
   #+end_src

** XML

   #+name: programming
   #+begin_src emacs-lisp :tangle no
     (use-package nxml-mode
       :defer t
       :config
       (progn
         (defun nxml-where ()
           "Display the hierarchy of XML elements the point is on as a path."
           (interactive)
           (let ((path nil))
             (save-excursion
               (save-restriction
                 (widen)
                 (while (and (< (point-min) (point)) ;; Doesn't error if point is at beginning of buffer
                             (condition-case nil
                                 (progn
                                   (nxml-backward-up-element) ; always returns nil
                                   t)
                               (error nil)))
                   (setq path (cons (xmltok-start-tag-local-name) path)))
                 (if (called-interactively-p t)
                     (message "/%s" (mapconcat 'identity path "/"))
                   (format "/%s" (mapconcat 'identity path "/")))))))

         (bind-key "C-c C-p" 'nxml-where)))
   #+end_src

** Fish

   #+name: programming
   #+begin_src emacs-lisp :tangle no
     (use-package fish-mode
       :mode (("\\.fish$" . fish-mode))
       :config
       (progn

         (defun td/setup-fish-mode ()
           (setq-local tab-width 2))

         (add-hook 'fish-mode-hook #'td/setup-fish-mode)))
   #+end_src

** Shell

   #+name: programming
   #+begin_src emacs-lisp :tangle no
     (use-package sh-script
       :defer t
       :init
       (setq-default sh-basic-offset 2))
   #+end_src

* Org

** Basic Settings

   #+NAME: org
   #+BEGIN_SRC emacs-lisp :tangle no
     (use-package org
       :config
       (progn
         (setq org-directory "~/Documents/"
               org-default-notes-file (expand-file-name "inbox.org" org-directory))

         (setq org-capture-templates
               '(("t" "To-do" entry
                  (file+headline "" "Inbox")
                  "* TODO %u %?"
                  :clock-keep t :kill-buffer t)
                 ("r" "Links to read" checkitem
                  (file+headline "" "Reading list")
                  "[ ] %?"
                  :clock-keep t :kill-buffer t)
                 ("l" "Download" checkitem
                  (file+headline "" "Download")
                  "[ ] %?"
                  :clock-keep t :kill-buffer t)))

         (setq org-goto-interface 'outline-path-completion
               org-log-done 'time
               org-log-into-drawer t
               org-refile-allow-creating-parent-nodes 'confirm
               org-refile-use-outline-path t
               org-return-follows-link t
               org-catch-invisible-edits 'show-and-error)

         (setq org-todo-keywords
               '((sequence "TODO(t)" "STARTED(s!)" "WAITING(w@/!)"
                           "|" "CANCELED(c@)" "DONE(d!)")))

         (setq org-src-fontify-natively t
               org-src-tab-acts-natively t)

         (setq org-hide-leading-stars t)))
   #+END_SRC

** Agenda

*** Basic Configuration

    #+NAME: org
    #+BEGIN_SRC emacs-lisp :tangle no
      (use-package org-agenda
        :commands (org-agenda org-agenda-list)
        :config
        (setq org-agenda-files
              '("~/Documents/inbox.org" "~/Documents/projects.org" "~/Documents/archives.org")
              org-agenda-skip-unavailable-files t
              org-agenda-skip-deadline-if-done nil
              org-agenda-skip-scheduled-if-done nil
              org-agenda-restore-windows-after-quit t
              org-agenda-window-setup 'current-window
              org-agenda-show-all-dates t
              org-agenda-show-log t))
    #+END_SRC

*** Custom Agenda Commands

    Below are our custom agenda commands:

    | Key | Description                                          |
    |-----+------------------------------------------------------|
    | =d=   | Timeline for today, and next actions from todo lists |
    | =w=   | Items with status WAITING                            |
    | =n=   | Next actions                                         |
    | =r=   | Weekly review                                        |

    #+NAME: org
    #+BEGIN_SRC emacs-lisp :tangle no
      (setq org-agenda-custom-commands
            '(("d" "Agenda + Next Actions" ((agenda) (todo "TODO")))
              ("w" todo "WAITING" nil)
              ("n" todo "TODO" nil)
              ("r" "Weekly Review"
               ((agenda "" ((org-agenda-ndays 7)))
                ;; type "l" in the agenda to review logged items
                (stuck "")
                (todo "PROJECT")
                (todo "MAYBE")
                (todo "WAITING")))))

    #+END_SRC

*** Automatically Show Agenda

    I tend not to consult the agenda often enough, so let's show it
    after Emacs is idle for a while.

    #+NAME: org
    #+BEGIN_SRC emacs-lisp :tangle no
      (defun td/jump-to-org-agenda ()
        (interactive)
        (let ((buf (get-buffer "*Org Agenda*"))
              wind)
          (if buf
              (if (setq wind (get-buffer-window buf))
                  (select-window wind)
                (if (called-interactively-p)
                    (progn
                      (select-window (display-buffer buf t t))
                      (org-fit-window-to-buffer))
                  (with-selected-window (display-buffer buf)
                    (org-fit-window-to-buffer))))
            (call-interactively 'org-agenda-list))))

      (run-with-idle-timer 2400 t 'td/jump-to-org-agenda)
    #+END_SRC

** Tags

   Org headlines can be tagged such that they are easier to find and
   filter. Here we set up reusable tags with mnemonic shortcuts.

   #+NAME: org
   #+BEGIN_SRC emacs-lisp :tangle no
     (setq org-tag-alist '(("@work" . ?W)     ; Contexts
                           ("@home" . ?H)
                           ("@school" . ?S)
                           ("@errand" . ?E)
                           ("build" . ?b)     ; Task types
                           ("earn" . ?e)
                           ("learn" . ?l)
                           ("focus" . ?f)     ; Task statuses
                           ("someday" . ?s)
                           ("delegate" . ?d)))
   #+END_SRC

** Exporting

   #+NAME: org
   #+BEGIN_SRC emacs-lisp :tangle no
     (setq org-hide-emphasis-markers t
           org-export-with-section-numbers nil
           org-export-backends '(html latex md))
   #+END_SRC

*** HTML

   Exporting options for HTML backend.

   #+NAME: org
   #+BEGIN_SRC emacs-lisp :tangle no
     (setq org-html-preamble nil
           org-html-postamble nil
           org-html-head-include-default-style nil
           org-html-head-include-scripts nil
           org-html-head
           (concat "<link rel=\"stylesheet\" type=\"text/css\" href=\"org.css\" />\n"
                   "<meta name=\"viewport\" content=\"initial-scale=1,maximum-scale=1\" />")
           org-html-text-markup-alist
           '((bold . "<strong>%s</strong>")
             (code . "<code>%s</code>")
             (italic . "<em>%s</em>")
             (strike-through . "<del>%s</del>")
             (underline . "<dfn>%s</dfn>") ; Somewhat arbitrary
             (verbatim . "<kbd>%s</kbd>")))
   #+END_SRC

*** Latex

    Exporting options for Latex backend.
    - Hightlight code blocks.

    #+BEGIN_SRC emacs-lisp :tangle no
      (setq  org-export-latex-listings 'minted)
    #+END_SRC

** Templates

   Org mode provides a mechanism for inserting [[http://orgmode.org/manual/Easy-Templates.html][templates]] into Org
   documents. To insert a structural element, type a =<=, followed by a
   template selector and =<TAB>=.

** Babel

   =org-babel= allows me to embed and evaluate code inside org files. It is
   quite useful but also impose some security risks, so I only enables a
   handful number of languages.

   #+NAME: org
   #+BEGIN_SRC emacs-lisp :tangle no
     (use-package ob-core
       :defer t
       :config
       (progn
         (org-babel-do-load-languages
          'org-babel-load-languages
          '((calc . t)
            (http . t)
            (python . t)
            (sql . t)
            (sqlite . t)
            (elasticsearch . t)))

         (defun td/org-babel-whitelist (lang body)
           (not (or (string= lang "http")
                    (string= lang "es"))))

         (setq org-confirm-babel-evaluate #'td/org-babel-whitelist)))
   #+END_SRC

** Key Bindings

*** Hierarchy

    | Binding        | Function                                     |
    |----------------+----------------------------------------------|
    | =M-<left/right>= | Promote/demote current headline or list item |
    | =M-<enter>=      | Create new item at current level             |
    | =M-S-<enter>=    | Create new TODO at current level             |

*** To-Dos

    | Binding     | Function                                       |
    |-------------+------------------------------------------------|
    | =C-c C-t=     | Cycle state                                    |
    | =C-c C-s=     | Schedule it                                    |
    | =C-c C-d=     | Set deadline                                   |
    | =C-c <comma>= | Set priority                                   |
    | =S-<up/down>= | Increase/decrease priority of current headline |
    | =C-c C-c=     | Toggle checkbox state                          |
    | =C-u C-c C-c= | Toggle checkbox presence                       |

*** Links

    | Binding | Function                    |
    |---------+-----------------------------|
    | =C-c C-l= | Insert link or edit current |

*** Dates and Times

    | Binding               | Function                                              |
    |-----------------------+-------------------------------------------------------|
    | =C-c .=                 | Insert timestamp (use twice to insert range)          |
    | =C-c !=                 | Insert inactive timestamp (doesn't appear in agendas) |
    | =C-u C-c .= / =C-u C-c != | Like above but including time                         |
    | =S-<left/right>=        | Increment/decrement by day                            |
    | =S-<up/down>=           | Increment/decrement segment at cursor                 |
    | =C-c C-y=               | Evaluate time range and insert after range text       |

*** Tags

    | Binding | Function       |
    |---------+----------------|
    | =C-c C-q= | Tag a headline |

*** Archiving

    | Binding         | Function                                                |
    |-----------------+---------------------------------------------------------|
    | =C-c C-x C-a=     | Archive current item                                    |
    | =C-u C-c C-x C-s= | Prompt to archive each non-TODO subtree of current item |

*** Source Code

    | Binding            | Function                              |
    |--------------------+---------------------------------------|
    | =C-c <single-quote>= | Edit current ~SRC~ block in native mode |

*** Customization

   #+NAME: org
   #+BEGIN_SRC emacs-lisp :tangle no
     (bind-key "C-c o a" #'org-agenda)
     (bind-key "C-c o c" #'org-capture)
     (bind-key "C-c o l" #'org-store-link)
   #+END_SRC

* Management

** Deft

   I use =Deft= to manage my =org-mode= files.

   #+NAME: management
   #+BEGIN_SRC emacs-lisp :tangle no
     (use-package deft
       :bind ("C-c b d" . deft)
       :config
       (progn
         (setq deft-extension "org"
               deft-text-mode 'org-mode
               deft-directory "~/Documents"
               deft-strip-title-regexp "\\(?:^%+\\|#\\+[[:alpha:]]+:\\|^[#* ]+\\|-\\*-[[:alpha:]]+-\\*-\\|#+$\\)")))
   #+END_SRC

** Shell

   #+name: management
   #+begin_src emacs-lisp :tangle no
     (use-package eshell
       :defer t
       :init
       (progn
         (setq eshell-list-files-after-cd t)

         (defun td/find-eshell ()
           (interactive)
           (if (get-buffer "*eshell*")
               (switch-to-buffer-other-window "*eshell*")
             (split-window-sensibly (selected-window))
             (other-window 1)
             (eshell)))

         (defun td/find-eshell-default-directory ()
           (interactive)
           (let ((cwd default-directory))
             (td/find-eshell)
             (eshell/cd cwd)))

         (bind-keys :map td/custom-map
                    ("t" . td/find-eshell)
                    ("s" . td/find-eshell-default-directory))
         :config
         (progn
           (defmacro td/with-face (str &rest properties)
             `(propertize ,str 'face (list ,@properties)))

           (defun td/eshell-pwd ()
             (replace-regexp-in-string
              (regexp-quote (expand-file-name "~"))
              "~"
              (eshell/pwd)))

           (defun td/eshell-prompt ()
             (format
              "\n%s@%s in %s\n%s "
              (td/with-face user-login-name :foreground "#dc322f")
              (td/with-face (or (getenv "HOST") system-name) :foreground "#b58900")
              (td/with-face (td/eshell-pwd) :foreground "#859900")
              (if (= (user-uid) 0) (with-face "#" :foreground "red") "$")))

           (defalias 'eshell/e 'find-file-other-window)

           (defun eshell/open (args)
             (interactive)
             (shell-command
              (concat (case system-type
                        ((darwin) "open")
                        ((windows-nt) "start")
                        (t "xdg-open"))
                      (format " %s" args))))

           (setq eshell-prompt-function #'td/eshell-prompt
                 eshell-prompt-regexp "^[^#$\\n]*[#$] "
                 eshell-highlight-prompt nil))))
   #+end_src

** TRAMP

   #+name: management
   #+begin_src emacs-lisp :tangle no
     (use-package tramp
       :defer t
       :config
       (progn
         (setq password-cache-expiry nil
               tramp-debug-buffer t
               tramp-default-method "ftp")

         (add-to-list 'auth-sources "~/.emacs.d/authinfo.gpg")
         (setq ange-ftp-netrc-filename "~/.emacs.d/authinfo.gpg")))
   #+end_src

** Dired

   #+name: management
   #+begin_src emacs-lisp :tangle no
     (use-package dired
       :defer t
       :config
       (progn
         (setq dired-listing-switches "-alh"
               dired-recursive-copies 'always
               dired-recursive-deletes 'always)

         (defun td/dired-back-to-top ()
           (interactive)
           (goto-char (point-min))
           (dired-next-line 4))

         (defun td/dired-jump-to-bottom ()
           (interactive)
           (goto-char (point-max))
           (dired-next-line -1))

         (bind-keys :map dired-mode-map
                    ("M-<" . td/dired-back-to-top)
                    ("M->" . td/dired-jump-to-bottom))))
   #+end_src

** Recent files

   #+name: management
   #+begin_src emacs-lisp :tangle no
     (use-package recentf
       :defer 1
       :config
       (progn
         (setq recentf-auto-cleanup "9:00pm"
               recentf-max-saved-items 256)

         (add-hook 'server-visit-hook #'recentf-save-list)

         (add-to-list 'recentf-exclude "elpa")

         (defun recentf-ido-find-file ()
           "Find a recent file using Ido."
           (interactive)
           (let ((file (ido-completing-read "Recent file: " recentf-list nil t)))
             (when file
               (find-file file))))

         (bind-key "C-c ;" #'recentf-ido-find-file)

         (recentf-mode t)))
   #+end_src

** EMMS

   #+name: management
   #+begin_src emacs-lisp :tangle no
     (use-package emms
       :defer t
       :config
       (progn
         (require 'emms-setup)

         (emms-standard)
         (emms-default-players)

         (setq emms-source-file-default-directory "~/Music/"
               emms-info-asynchronously t
               emms-show-format "♫ %s"
               emms-repeat-playlist t)

         (require 'emms-mode-line)
         (require 'emms-mode-line-icon)
         (setq emms-mode-line-format " [%s] ")
         (emms-mode-line 1)

         (define-emms-simple-player afplay '(file)
           (regexp-opt '(".mp3" ".m4a" ".aac"))
           "afplay")
         (setq emms-player-list `(,emms-player-afplay))))

     (use-package emms-browser
       :bind (("<f7>" . emms-smart-browse))
       :config
       (setq emms-browser-covers
             '("cover_small.jpg" "cover_medium.jpg" "cover.jpg")))
   #+end_src

** Evernote

   #+NAME: management
   #+BEGIN_SRC emacs-lisp :tangle no
     (use-package epic
       :commands (epic-create-note-from-region
       epic-insert-selected-note-as-org-links
       epic-create-note-from-org-buffer)
       :config
       (setq epic-evernote-mail-address "tungd.5740caa@m.evernote.com"))
   #+END_SRC

* Configuration Layout

  Here we define the =emacs.el= file that gets generated by the source
  blocks in our Org document. This is the file that actually gets
  loaded on startup.

  #+BEGIN_SRC emacs-lisp :tangle yes :noweb no-export :exports code
    ;;; emacs.el --- Emacs configuration generated via Org Babel

    ;;; Commentary:

    ;; Do not modify this file by hand.  It was automatically generated
    ;; from `emacs.org` in the same directory.  See that file for more
    ;; information.

    ;;; Code:

    ;; Configuration group: init-before
    <<init-before>>

    ;; Configuration group: appearance
    <<appearance>>

    ;; Configuration group: editing
    <<editing>>

    ;; Configuration group: navigation-completion
    <<navigation-completion>>

    ;; Configuration group: programming
    <<programming>>

    ;; Configuration group: management
    <<management>>

    ;; Configuration group: org
    <<org>>

    ;; Configuration group: init-after
    <<init-after>>

    ;; emacs.el ends here
  #+END_SRC

* Wish List

  Functionality I want or things that need to be fixed:

  - [[http://nschum.de/src/emacs/kill-ring-search/][kill-ring-search]] seems to be pretty useful. I remember using Unite
    Yankring plugin years ago.
  - [[http://nschum.de/src/emacs/rotate-text/][rotate-text]] is also interesting.
  - tags
  - async
  - Hydra for keymap management?
